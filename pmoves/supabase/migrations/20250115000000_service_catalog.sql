-- PMOVES Service Catalog - Dynamic Service Discovery
--
-- This table provides a centralized registry for all PMOVES services,
-- enabling dynamic service URL resolution via Supabase.
--
-- Services can be discovered by:
-- 1. Querying this table via REST API
-- 2. Filtering by tier (data, api, llm, worker, media, agent, ui)
-- 3. Checking health status via health_check_url
-- 4. Using metadata for custom service properties

-- Create the service catalog table
CREATE TABLE IF NOT EXISTS pmoves_core.service_catalog (
  -- Primary identification
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  slug TEXT NOT NULL UNIQUE,

  -- Service metadata
  name TEXT NOT NULL,
  description TEXT,

  -- Service discovery
  health_check_url TEXT NOT NULL,
  default_port INTEGER,
  env_var TEXT,  -- Environment variable name for custom URL override

  -- Tier classification (matches 6-tier environment architecture)
  tier TEXT NOT NULL CHECK (tier IN ('data', 'api', 'llm', 'worker', 'media', 'agent', 'ui')),

  -- Extensibility
  tags JSONB DEFAULT '{}'::jsonb,
  metadata JSONB DEFAULT '{}'::jsonb,

  -- Lifecycle
  active BOOLEAN DEFAULT true,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Indexes for common query patterns
CREATE INDEX IF NOT EXISTS idx_service_catalog_slug ON pmoves_core.service_catalog(slug);
CREATE INDEX IF NOT EXISTS idx_service_catalog_tier ON pmoves_core.service_catalog(tier);
CREATE INDEX IF NOT EXISTS idx_service_catalog_active ON pmoves_core.service_catalog(active);
CREATE INDEX IF NOT EXISTS idx_service_catalog_tags ON pmoves_core.service_catalog USING GIN (tags);

-- Updated at trigger
CREATE OR REPLACE FUNCTION pmoves_core.update_service_catalog_updated_at()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER service_catalog_updated_at
  BEFORE UPDATE ON pmoves_core.service_catalog
  FOR EACH ROW
  EXECUTE FUNCTION pmoves_core.update_service_catalog_updated_at();

-- Enable Row Level Security
ALTER TABLE pmoves_core.service_catalog ENABLE ROW LEVEL SECURITY;

-- Public read access for service discovery (active services only)
-- Note: Service catalog must be readable for dynamic service discovery
CREATE POLICY "Service catalog is publicly readable"
  ON pmoves_core.service_catalog FOR SELECT
  TO anon, authenticated
  USING (active = true);

-- Service role can modify active services
CREATE POLICY "Service catalog is writable by service role"
  ON pmoves_core.service_catalog FOR ALL
  TO service_role
  USING (active = true)
  WITH CHECK (active = true);

-- Seed initial PMOVES services
INSERT INTO pmoves_core.service_catalog (slug, name, description, health_check_url, default_port, env_var, tier, tags, metadata) VALUES
  -- Data Tier
  ('qdrant', 'Qdrant Vector Database', 'Vector embeddings storage for semantic search', 'http://qdrant:6333/healthz', 6333, 'QDRANT_URL', 'data', '{"vector": true, "embeddings": true, "search": "semantic"}'::jsonb, '{"collection": "pmoves_chunks", "dimension": 384}'::jsonb),
  ('neo4j', 'Neo4j Graph Database', 'Knowledge graph storage for entity relationships', 'http://neo4j:7474', 7474, 'NEO4J_URL', 'data', '{"graph": true, "relationships": true, "traversal": true}'::jsonb, '{"protocol": "bolt", "bolt_port": 7687}'::jsonb),
  ('meilisearch', 'Meilisearch Full-Text Search', 'Keyword search with typo tolerance', 'http://meilisearch:7700/health', 7700, 'MEILISEARCH_URL', 'data', '{"search": true, "fulltext": true, "fuzzy": true}'::jsonb, '{"ranking": "tfidf", "typo_tolerance": "adaptive"}'::jsonb),
  ('minio', 'MinIO Object Storage', 'S3-compatible storage for assets and outputs', 'http://minio:9000/minio/health/live', 9000, 'MINIO_ENDPOINT', 'data', '{"storage": true, "s3": true, "buckets": ["assets", "outputs"]}'::jsonb, '{"console_port": 9001}'::jsonb),
  ('postgres', 'PostgreSQL Database', 'Primary relational database via Supabase', 'http://supabase_kong_PMOVES.AI:8000/rest/v1/', 8000, 'SUPABASE_URL', 'data', '{"database": true, "relational": true, "pgvector": true}'::jsonb, '{"provider": "supabase"}'::jsonb),

  -- API Tier
  ('postgrest', 'PostgREST API', 'Auto-generated REST API for PostgreSQL', 'http://postgrest:3000/', 3000, 'POSTGREST_URL', 'api', '{"api": true, "rest": true, "autogenerated": true}'::jsonb, '{"schema": "public"}'::jsonb),
  ('presign', 'Presign Service', 'MinIO URL presigner for short-lived download URLs', 'http://presign:8088/healthz', 8088, 'PRESIGN_URL', 'api', '{"storage": true, "presign": true, "security": true}'::jsonb, '{"allowed_buckets": ["assets", "outputs"]}'::jsonb),
  ('hirag-v2', 'Hi-RAG Gateway v2', 'Next-gen hybrid RAG with cross-encoder reranking', 'http://hi-rag-gateway-v2:8086/healthz', 8086, 'HIRAG_URL', 'api', '{"rag": true, "hybrid": true, "rerank": true, "v2": true}'::jsonb, '{"gpu_port": 8087, "features": ["vector", "graph", "fulltext"]}'::jsonb),
  ('hirag-v1', 'Hi-RAG Gateway v1', 'Legacy hybrid RAG implementation', 'http://hi-rag-gateway:8089/healthz', 8089, 'HIRAG_V1_URL', 'api', '{"rag": true, "hybrid": true, "legacy": true, "v1": true}'::jsonb, '{"gpu_port": 8090, "status": "deprecated"}'::jsonb),

  -- LLM Tier
  ('tensorzero', 'TensorZero Gateway', 'Centralized LLM gateway with observability', 'http://tensorzero-gateway:3030/openapi.json', 3030, 'TENSORZERO_URL', 'llm', '{"llm": true, "gateway": true, "observability": true, "multi_provider": true}'::jsonb, '{"ui_port": 4000, "clickhouse_port": 8123}'::jsonb),
  ('tensorzero-ui', 'TensorZero UI Dashboard', 'Metrics dashboard and request inspection', 'http://tensorzero-ui:4000', 4000, 'TENSORZERO_UI_URL', 'llm', '{"ui": true, "dashboard": true, "metrics": true}'::jsonb, '{}'::jsonb),

  -- Worker Tier
  ('extract-worker', 'Extract Worker', 'Text embedding and indexing service', 'http://extract-worker:8083/healthz', 8083, 'EXTRACT_URL', 'worker', '{"worker": true, "embeddings": true, "indexing": true}'::jsonb, '{"model": "all-MiniLM-L6-v2"}'::jsonb),
  ('langextract', 'LangExtract', 'Language detection and NLP preprocessing', 'http://langextract:8084/healthz', 8084, 'LANGEXTRACT_URL', 'worker', '{"worker": true, "nlp": true, "language_detection": true}'::jsonb, '{}'::jsonb),
  ('pdf-ingest', 'PDF Ingest', 'Document ingestion orchestrator', 'http://pdf-ingest:8092/healthz', 8092, 'PDF_INGEST_URL', 'worker', '{"worker": true, "pdf": true, "ingestion": true}'::jsonb, '{}'::jsonb),
  ('notebook-sync', 'Notebook Sync', 'SurrealDB Open Notebook synchronizer', 'http://notebook-sync:8095/healthz', 8095, 'NOTEBOOK_SYNC_URL', 'worker', '{"worker": true, "sync": true, "notebook": true}'::jsonb, '{"poll_interval": 300}'::jsonb),

  -- Media Tier
  ('pmoves-yt', 'PMOVES.YT', 'YouTube ingestion service', 'http://pmoves-yt:8077/healthz', 8077, 'PMOVES_YT_URL', 'media', '{"media": true, "youtube": true, "ingestion": true}'::jsonb, '{"nats_events": ["ingest.transcript.ready.v1"]}'::jsonb),
  ('ffmpeg-whisper', 'FFmpeg Whisper', 'Media transcription with GPU acceleration', 'http://ffmpeg-whisper:8078/healthz', 8078, 'WHISPER_URL', 'media', '{"media": true, "transcription": true, "gpu": true}'::jsonb, '{"model": "faster-whisper", "model_size": "small"}'::jsonb),
  ('media-video', 'Media Video Analyzer', 'Object/frame analysis with YOLOv8', 'http://media-video:8079/healthz', 8079, 'MEDIA_VIDEO_URL', 'media', '{"media": true, "video": true, "yolo": true}'::jsonb, '{"model": "yolov8", "confidence": 0.25}'::jsonb),
  ('media-audio', 'Media Audio Analyzer', 'Audio emotion and speaker detection', 'http://media-audio:8082/healthz', 8082, 'MEDIA_AUDIO_URL', 'media', '{"media": true, "audio": true, "emotion": true}'::jsonb, '{"model": "superb/hubert-large-superb-er"}'::jsonb),
  ('render-webhook', 'Render Webhook', 'ComfyUI render callback handler', 'http://render-webhook:8085/healthz', 8085, 'RENDER_WEBHOOK_URL', 'media', '{"media": true, "webhook": true, "comfyui": true}'::jsonb, '{}'::jsonb),

  -- Agent Tier
  ('agent-zero', 'Agent Zero', 'Control-plane orchestrator with embedded agent runtime', 'http://agent-zero:8080/healthz', 8080, 'AGENT_ZERO_URL', 'agent', '{"agent": true, "orchestration": true, "mcp": true}'::jsonb, '{"ui_port": 8081, "mcp_path": "/mcp/*"}'::jsonb),
  ('archon', 'Archon', 'Supabase-driven agent service with prompt management', 'http://archon:8091/healthz', 8091, 'ARCHON_URL', 'agent', '{"agent": true, "supabase": true, "prompts": true}'::jsonb, '{"mcp_port": 8051, "agents_port": 8052}'::jsonb),
  ('deepresearch', 'DeepResearch', 'LLM-based research planner', 'http://deepresearch:8098/healthz', 8098, 'DEEPRESEARCH_URL', 'agent', '{"agent": true, "research": true, "planning": true}'::jsonb, '{"provider": "alibaba-tongyi", "timeout": 600}'::jsonb),
  ('supaserch', 'SupaSerch', 'Multimodal holographic deep research orchestrator', 'http://supaserch:8099/metrics', 8099, 'SUPASERCH_URL', 'agent', '{"agent": true, "research": true, "multimodal": true}'::jsonb, '{"nats_subject": "supaserch.request.v1"}'::jsonb),
  ('mesh-agent', 'Mesh Agent', 'Distributed node announcer for multi-host orchestration', 'http://mesh-agent:8096/healthz', 8096, 'MESH_AGENT_URL', 'agent', '{"agent": true, "orchestration": true, "multi_host": true}'::jsonb, '{"announce_interval": 15}'::jsonb),

  -- UI Tier
  ('pmoves-ui', 'PMOVES Central UI', 'Main dashboard and user interface', 'http://pmoves-ui:4482', 4482, 'PMOVES_UI_URL', 'ui', '{"ui": true, "dashboard": true, "nextjs": true}'::jsonb, '{}'::jsonb),
  ('archon-ui', 'Archon UI', 'Agent form and prompt management interface', 'http://archon:3737', 3737, 'ARCHON_UI_URL', 'ui', '{"ui": true, "agent": true, "forms": true}'::jsonb, '{"embedded": true}'::jsonb),
  ('tokenism-ui', 'Tokenism UI', 'Geometry/CHIT protocol visualization and testing', 'http://tokenism-ui:8504', 8504, 'TOKENISM_UI_URL', 'ui', '{"ui": true, "geometry": true, "chit": true}'::jsonb, '{"profile": "data"}'::jsonb)

ON CONFLICT (slug) DO NOTHING;

-- Create helper function for service URL resolution
CREATE OR REPLACE FUNCTION pmoves_core.resolve_service_url(
  service_slug TEXT,
  DEFAULT_PORT INTEGER DEFAULT 80
)
RETURNS TEXT AS $$
DECLARE
  service_record RECORD;
  env_value TEXT;
BEGIN
  -- First check for environment variable override
  SELECT s.env_var, s.default_port INTO service_record
  FROM pmoves_core.service_catalog s
  WHERE s.slug = service_slug AND s.active = true;

  IF NOT FOUND THEN
    -- Fall back to service name DNS resolution
    RETURN 'http://' || service_slug || ':' || DEFAULT_PORT;
  END IF;

  -- Check if there's an environment variable override
  IF service_record.env_var IS NOT NULL THEN
    -- Note: This would need to be called with env_var as a parameter
    -- in a real implementation, since we can't read env vars directly in SQL
    NULL;
  END IF;

  -- Return the health check URL as the service URL
  RETURN service_record.health_check_url;
END;
$$ LANGUAGE plpgsql STABLE;

-- Create view for active services by tier
CREATE OR REPLACE VIEW pmoves_core.active_services_by_tier AS
SELECT
  tier,
  jsonb_agg(
    jsonb_build_object(
      'slug', slug,
      'name', name,
      'description', description,
      'health_check_url', health_check_url,
      'default_port', default_port,
      'env_var', env_var,
      'tags', tags,
      'metadata', metadata
    ) ORDER BY slug
  ) AS services
FROM pmoves_core.service_catalog
WHERE active = true
GROUP BY tier
ORDER BY tier;

-- Grant permissions
GRANT USAGE ON SCHEMA pmoves_core TO anon, authenticated, service_role;
GRANT SELECT ON ALL TABLES IN SCHEMA pmoves_core TO anon, authenticated;
GRANT EXECUTE ON FUNCTION pmoves_core.resolve_service_url(TEXT, INTEGER) TO anon, authenticated, service_role;
GRANT SELECT ON ALL TABLES IN SCHEMA pmoves_core TO service_role;
GRANT SELECT, INSERT, UPDATE, DELETE ON TABLE pmoves_core.service_catalog TO service_role;

COMMENT ON TABLE pmoves_core.service_catalog IS 'Dynamic service registry for PMOVES microservice discovery';
COMMENT ON VIEW pmoves_core.active_services_by_tier IS 'Active services grouped by tier for easy discovery';
COMMENT ON FUNCTION pmoves_core.resolve_service_url(TEXT, INTEGER) IS 'Resolve service URL with fallback to DNS-based discovery';
